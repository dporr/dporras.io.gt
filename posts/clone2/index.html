<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Kage bunshin no jutsu: clone(2)</title><meta name=description content="Collection of posts about things I learn and try to explain: hacking, code, backend, aws, devops, devsecops and whatever I find interesting"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=http://aleph.theartofhacking.club/css/bootstrap.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Roboto:400,300,700,400italic"><link rel=stylesheet href=http://aleph.theartofhacking.club/css/font-awesome.min.css><link rel=stylesheet href=http://aleph.theartofhacking.club/css/owl.carousel.css><link rel=stylesheet href=http://aleph.theartofhacking.club/css/owl.theme.css><link href=http://aleph.theartofhacking.club/css/style.pink.css rel=stylesheet id=theme-stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link href=http://aleph.theartofhacking.club/css/custom.css rel=stylesheet><link rel="shortcut icon" href=http://aleph.theartofhacking.club/img/favicon.png></head><body><div id=all><div class=container-fluid><div class="row row-offcanvas row-offcanvas-left"><div id=sidebar class="col-xs-6 col-sm-4 col-md-3 sidebar-offcanvas"><div class=sidebar-content><h1 class=sidebar-heading><a href=http://aleph.theartofhacking.club/>The Art of hacking - blog</a></h1><p class=sidebar-p>AppSec Engineer. Trying to do low level stuff</p><ul class=sidebar-menu><li><a href=http://aleph.theartofhacking.club/posts/>Home</a></li><li><a href=http://aleph.theartofhacking.club/about/>About</a></li><li><a href=http://aleph.theartofhacking.club/contact/>Get in touch</a></li></ul><p class=social><a href=mailto:diego.porras@owasp.org data-animate-hover=pulse class=email><i class="fa fa-envelope"></i></a>
<a href=https://github.com/dporr data-animate-hover=pulse class=external><i class="fa fa-github"></i></a></p><div class=copyright><p class=credit>&copy;2023 Diego Porras - Actually copy and reproduce whatever you want. DRM Free :D |
Template by <a href=https://bootstrapious.com/free-templates class=external>Bootstrapious.com</a>
& ported to Hugo by <a href=https://github.com/kishaningithub>Kishan B</a></p></div></div></div><div class="col-xs-12 col-sm-8 col-md-9 content-column white-background"><div class="small-navbar visible-xs"><button type=button data-toggle=offcanvas class="btn btn-ghost pull-left"> <i class="fa fa-align-left"></i>Menu</button><h1 class=small-navbar-heading><a href=http://aleph.theartofhacking.club/>The Art of hacking - blog</a></h1></div><div class=row><div class=col-lg-8><div class=content-column-content><h1>Kage bunshin no jutsu: clone(2)</h1><p>This entry talks about the clone(2) system call and the corresponding libc thin wrapper.
I talk about some issues I found whle using the syscall to solve <a href=https://osg.tuhh.de/Advent/02-clone/>Advent - day 2</a>.</p><h4 id=tldr>TL;DR</h4><ul><li>Process creation in linux</li><li>Namespaces in linux: CLONE_NEW*, CLONE_NEWNS, user namespaces.</li><li>Linux capabilities. CAP_SYS_ADMIN</li><li>Practical use of the namespaces API: clone(2)</li><li>My full solutions are available here: <a href=https://github.com/dporr/kernel_syscalls/tree/master/02-clone>https://github.com/dporr/kernel_syscalls/tree/master/02-clone</a></li></ul><h4 id=it-all-starts-with-fork2>It all starts with fork(2):</h4><p><a href=https://man7.org/tlpi/download/TLPI-24-Process_Creation.pdf>https://man7.org/tlpi/download/TLPI-24-Process_Creation.pdf</a></p><p>The most basic way of creating a new process in linux is using the <code>fork(2)</code> sycall. This syscall creates a new process with a new PID and the value of parent PID pointing to the caller of <code>fork</code>. If we take a look at the process representation inside of the kernel, we see that the task definition of te current process points to that PID in <a href=https://elixir.bootlin.com/linux/v5.16/source/include/linux/sched.h#L958><code>struct task_struct->parent</code></a> and <a href=https://elixir.bootlin.com/linux/v5.16/source/include/linux/sched.h#L955><code>struct task_struct->real_parent</code></a> *Note that task_struct resides on kernel memory and thus is unmapped in userspace, therefore we need a driver or something allowed to read kernel memory to appreciate this fact at runtime.</p><p>The disadvantage of fork is that the new process shares a copy of the parent&rsquo;s stack, namespace and open file descriptors among other things. This by itself may not be an issue, but flexibility during process creation perhaps is.</p><h4 id=clone2>clone(2)</h4><p>In the other hand we have a more flexible way of instantiating a process by calling clone(2) and clone3(2). As stated in the manpages</p><blockquote><p>By contrast with fork(2), these system calls provide more precise
control over what pieces of execution context are shared between
the calling process and the child process. For example, using
these system calls, the caller can control whether or not the two
processes share the virtual address space, the table of file
descriptors, and the table of signal handlers. These system
calls also allow the new child process to be placed in separate
namespaces(7).&#171; The clone wrapper in libc has the following prototype:</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>clone</span> (<span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>__fn) (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>__arg), <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>__child_stack,
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>int</span> __flags, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>__arg, ...) __THROW;
</span></span></code></pre></div><p>Interesting diferences is that we need to specify the function from where execution will start in the child and we also need to specify a memory area for the child stack, using different flags we can specify other properties of the child like wich group thread this process will belong, if we need the child to have a separate namespace from the parent and other interesting stuff.</p><h3 id=solving-advent-of-code-day-2>Solving advent of code day 2</h3><p>There are 4 tasks for this day:</p><pre><code>1. Implement fork() with clone().
2. Create a process-thread chimera, i.e a process which shares its address space with a different process, with clone().
3. Create a real thread with clone() that shares the address space and that is put in the same thread group.
4. (Extra) Fork a process into a new UID namespace and become root therein. getuid() will show you your success.
</code></pre><p>While solving the first of them with the most basic code I faced some errors:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;fork&#34;</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> child_pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>clone</span>(child_entry, <span style=color:#f92672>&amp;</span>stack[<span style=color:#ae81ff>4096</span>] , CLONE_NEWNS, argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall_write</span>(<span style=color:#e6db74>&#34;Created process: &#34;</span>, child_pid);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(child_pid <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;clone&#34;</span>);
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> make
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> .<span style=color:#f92672>/</span>clone fork
</span></span><span style=display:flex><span>Created process: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>clone: Operation not permitted
</span></span></code></pre></div><p>The flexibility clone offers is subject to the user having the right access level, that&rsquo;s when capabilities come to play. The concept of capabilities in linux isn&rsquo;t new to me. I have used them for privesc before, but observing why and when are they required teaches in a different way. If you observe the code you can notice I&rsquo;m passing the <code>CLONE_NEWNS</code> flag and this flag requires <code>CAP_SYS_ADMIN</code>. In the manpage for linux capabilities <a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>capabilities(7)</a> is stated that</p><blockquote><p>employ CLONE_* flags that create new namespaces with
clone(2) and unshare(2) (but, since Linux 3.8, creating
user namespaces does not require any capability);
* access privileged perf event information;</p></blockquote><p>So, what exactly does this mean? Do we need <code>CAP_SYS_ADMIN</code> or not? There are, as time of writting, 8 different <a href=https://man7.org/linux/man-pages/man7/namespaces.7.html>namespaces(7)</a> that offer different type of isolation for global resources. Namespaces are identified with a named numerical costant, like <code>CLONE_NEWNS</code>. CLONE_NEWNS indicates that we are creating a new mount namespace, so the exception that appeared since linux 3.8 doesn&rsquo;t benefit us as we are creating a completely different flavor of namespace here.</p><p>In summary, this means that only a privileged user/process with the <code>CAP_SYS_ADMIN</code> can create a child process in a separate [mount] namespace from its parent.</p><p>My solution to the tasks is the follwoing:</p><h5 id=task-1>Task 1</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;fork&#34;</span>)) {
</span></span><span style=display:flex><span>        flags <span style=color:#f92672>=</span> SIGCHLD;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> child_pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>clone</span>(child_entry, <span style=color:#f92672>&amp;</span>stack[<span style=color:#ae81ff>4096</span>] , flags, arg);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>syscall_write</span>(<span style=color:#e6db74>&#34;Created process: &#34;</span>, child_pid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(child_pid <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;clone&#34;</span>);
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Nothing special for the &ldquo;fork&rdquo; call, with <code>SIGCHLD</code> we are simply indicaing that the child will notify the parent process that its execution is completed.</p><h5 id=task-2>Task 2</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;chimera&#34;</span>)){
</span></span><span style=display:flex><span>        flags <span style=color:#f92672>=</span> CLONE_VM;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> child_pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>clone</span>(child_entry, <span style=color:#f92672>&amp;</span>stack[<span style=color:#ae81ff>4096</span>] , flags, arg);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>syscall_write</span>(<span style=color:#e6db74>&#34;Created process: &#34;</span>, child_pid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(child_pid <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;clone&#34;</span>);
</span></span></code></pre></div><p>This is basically indicating that the child will share the virtual address space with the parent, meaning all local and global variables could be mutated from either the child or the parent and both parties are able to see those changes. In the end, they are functioning on the very same memory space.</p><h5 id=task-3>Task 3</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;thread&#34;</span>)){
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *Since Linux 2.5.35, the flags mask must also include CLONE_SIGHAND if  CLONE_THREAD
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *is  specified  (and  note  that,  since  Linux  2.6.0,  CLONE_SIGHAND also requires
</span></span></span><span style=display:flex><span><span style=color:#75715e>        *CLONE_VM to be included).
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>        flags <span style=color:#f92672>=</span> CLONE_VM <span style=color:#f92672>|</span> CLONE_THREAD <span style=color:#f92672>|</span> CLONE_SIGHAND;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> child_pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>clone</span>(child_entry, <span style=color:#f92672>&amp;</span>stack[<span style=color:#ae81ff>4096</span>] , flags, arg);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>syscall_write</span>(<span style=color:#e6db74>&#34;Created process: &#34;</span>, child_pid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(child_pid <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;clone&#34;</span>);
</span></span></code></pre></div><p>This one was a little tricky since <code>CLONE_THREAD</code> has a dependency on <code>CLONE_SIGHAND</code> and the later has a dependency on <code>CLONE_VM</code> since linux 2.5.35 according to the docs.</p><h5 id=task-4>Task 4</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#75715e>/*Inside the chikd*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(arg <span style=color:#f92672>!=</span> NULL){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> uid_map_fd;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        https://man7.org/linux/man-pages/man7/user_namespaces.7.html
</span></span></span><span style=display:flex><span><span style=color:#75715e>        The easies way o complying with the permissions requirements
</span></span></span><span style=display:flex><span><span style=color:#75715e>        is to run this as root.
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>((uid_map_fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;/proc/self/uid_map&#34;</span>, O_RDWR)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;open&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> uid_map <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0 0 1</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>write</span>(uid_map_fd,uid_map, <span style=color:#66d9ef>sizeof</span>(uid_map) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;write&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(uid_map_fd);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall_write</span>(<span style=color:#e6db74>&#34;: getuid()  = &#34;</span>, <span style=color:#a6e22e>getuid</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>setuid</span>(<span style=color:#ae81ff>0</span>) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> ) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;setuid&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>syscall_write</span>(<span style=color:#e6db74>&#34;: setuid() = &#34;</span>, <span style=color:#a6e22e>getuid</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*Inside the parent*/</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>(argv[<span style=color:#ae81ff>1</span>], <span style=color:#e6db74>&#34;user&#34;</span>)){
</span></span><span style=display:flex><span>        flags <span style=color:#f92672>=</span> CLONE_NEWUSER;
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*We need to signal the child that we want to override /proc/self/uid_map*/</span>
</span></span><span style=display:flex><span>        arg <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> child_pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>clone</span>(child_entry, <span style=color:#f92672>&amp;</span>stack[<span style=color:#ae81ff>4096</span>] , flags, arg);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>syscall_write</span>(<span style=color:#e6db74>&#34;Created process: &#34;</span>, child_pid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(child_pid <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;clone&#34;</span>);
</span></span></code></pre></div><p>The last one was a headache because writting to the file that sets the user and group mappingsa plus using setuid implies a set of permissions&mldr; in the end I gave up troubleshooting and just ran this part as root.</p><p>I learned a lot reading manpages and observing the different concepts materializing through code. In the end we only truly understand what we can code&mldr;
See you arround space cowboy!</p><h4 id=additional-reading>Additional reading</h4><ol><li><a href=https://ypl.coffee/parent-and-real-parent-in-task-struct/>https://ypl.coffee/parent-and-real-parent-in-task-struct/</a> (Good explanation of task_struct access + Kernel and Hacking stuff from a great hacker and ctf player)</li><li><a href=https://lwn.net/Articles/531114/>https://lwn.net/Articles/531114/</a> (Great searies on namespaces, basically the soul of modern containers)</li></ol></div></div></div></div></div></div></div><script src=http://aleph.theartofhacking.club/js/jquery.min.js></script>
<script src=http://aleph.theartofhacking.club/js/bootstrap.min.js></script>
<script src=http://aleph.theartofhacking.club/js/jquery.cookie.js></script><script src=http://aleph.theartofhacking.club/js/ekko-lightbox.js></script>
<script src=http://aleph.theartofhacking.club/js/jquery.scrollTo.min.js></script>
<script src=http://aleph.theartofhacking.club/js/masonry.pkgd.min.js></script>
<script src=http://aleph.theartofhacking.club/js/imagesloaded.pkgd.min.js></script>
<script src=http://aleph.theartofhacking.club/js/owl.carousel.min.js></script>
<script src=http://aleph.theartofhacking.club/js/front.js></script></body></html>